Quiz App
---------
Goals:
	User accessing the appplication will get a set of 10 MCQ questions which they would need
	to answer. They will be scored based on their answers to the quiz.
	This is completely Backend Web Application. 
	Hence, to verify the APIs, we'll be using Postman.
	
Tech Stacks Used: 
	1. Spring Boot 
	2. Java 11
	3. PostgreSQL

Dependencies Used:
	1. Spring Web :	Used to create the Web Application
	2. PostgreSQL Driver : 	It helps access data in PostgreSQL DB.
	3. Spring Data JPA:	It allows us to connect to the Spring app and the DB.
	4. Lombok:	For reducing Boilerplate code.
	   
Procedure:
	This Quiz web application is a Restful WebService.
	The questions being asked to the user, is stored in the PostgreSQL DB.
	
	The application has three layers, each with their own functions:
		1. Controller Layer:
			- It is responsible for interacting with the users and accept their requests.
			- Sends the requests to be processed in the service layer.
			- Returns the output from the service layer to the User. 
		
		2. Service Layer:
			- All the business logic required by the application stays here.
			- Processing is done here.
			- Controller Layer passes on the requests from the user to this layer, for processing
		
		3. DAO Layer:
			- This layer is responsible for interacting with the DB (perform CRUD operations)
			- DAO layer is used to decouple the Service layer from the DB.
			
	To implement the three layers mentioned above, there are three packages:
		com.example.quizwebapp.controller
		com.example.quizwebapp.service
		com.example.quizwebapp.dao
	which contains all of the Controller, Service and DAO classes respectively.
	
	The annotations used:
	1. @RestController
		- It tells the Spring framework that this class will be a Controller in the Spring MVC.
		- Since we are building a RESTful Web Application capable of serving REST APIs (GET, POST, PUT etc),
		  all the controllers in this application will be annotated with @RestController.
		- This annotation also combines @controller and @ResponseBody annotatios, so we don't need to use them seperately.
	
	2. @Service
		- It tells the Spring framework that this class will belong in the Service layer.
		- Signifies that the class is holding business logic.
	
	3. @Autowired
		- This annotation allows for automatic dependency injection
		- It automatically scans the components present in the current package and the sub packages.
		- Components are usually marked with @Component, @Service, @Repository or @Controller annotations.
	
	4. @Entity
		- It is used to show that a class can be mapped to a table.
		- In JPA, @Entity is used to show a table that's stored in a DB.
	
	5. @Table
		- Used to mention which table will be mapped to the Entity/Model class.
		
	6. @Id
		- Denotes which variable will serve as the Primary Key of the Entity class.
		
	7. @Data
		- This is present in the Lombok dependency.
		- It is used to add Getter and Setter methods for all the fields mentioned in a class.
		
	8. @Repository
		- It tells the Spring framework that this class/interface will belong in the DAO layer.
		- It signifies this class contains code for Database used for storage, retrieval, 
		  update, delete and search operations.
	
	9. @GetMapping()
		- Used to handle GET HTTP requests
		- This annotation tells the method of the controller to fetch something from the database. 
	
	10. @GetMapping("category/{category}")
		- Here, {category} is the templated part of the URL. User can input a value to this part.
		- This templated part is then mapped to the method's variable using 
		  @PathVariable annotation. 
	
	10. @PathVariable
		- This annotation maps the templated part of a URL to a variabe of the method.
		- In the below example, {category} gets mapped to String category:
				@GetMapping("category/{category}")
				public List<Question> getQuestionByCategory( @PathVariable("category") String category) {}
		- Since the templated part and the variable name is same, we can use 
		  (@PathVariable String category) instead of (@PathVariable("category") String category)
	
	11. @PostMapping
		- Used to handle POST HTTP requests.
		- This annotation tells the method of the controller to accept JSON format data from user.
		
	11. @RequestBody
		- When a user sends a request for adding something in the DB, it is accepted as a POST request.
		- The request stores the data sent by the user in it's body, in JSON format.
		- This annotation tells the Spring framework to extract the data stored in the body and convert it into class object.
		- This conversion is known as deserialization.
	
	Now coming to the DB, for each table we use in the application, we create one class.
	This class is called an Entity or a Model and contains the data of the application. 
	The fields (variables) used in the Entity/Model class, represents the columns present in the table.
	
	SQL uses "snake_casing" while Java uses "camelCasing".  
	For a column in the table named "difficult_level", we can use the variable name "difficultyLevel" in our model class.
	This is becasue we are using JPA, whose object-relational mapping (ORM) framework makes sure this happens.
	
	Make sure the PostgreSQL Table name uses the following naming conventions: https://www.geeksforgeeks.org/postgresql-naming-conventions/
	For example, if the table name is "table_name", we can use @Table(name = "TableName")
	
	We are adding a method in the QuestionController class to fetch all the questions of a particular category only.
	For this, the method accepts the category and sends it to the QuestionService class which in turn calls QuestionDAO class.
	Now we have created a custom method  in the QuestionDAO class named: findByCategory(String category).
	In our DB we have a column named "category" and this is why we named the method findByCategory().
	DataJPA can understand that we want to fetch the values based on the the category column.
	
	
	Next, we are taking data from the user to add in our table. 
	Data from the user has to be in the JSON format.
	By using @RequestBody annotation, we can convert the JSON format data into a class object and then store it in our DB.
	QuestionDAO interface implements JPARepository interface, due to which we are able to access the save() method.
	This method is used to save the class objects.
	In the service layer, we will invoke the save() method which will save the user's question to the DB. 
	
	We are going to add HTTP Response Status Codes and handle exceptions.
	For that we would need to return the Data as well as the Status Codes and till now we were returning only Data.
	This is where "ResponseEntity" saves the day. We are using ResponseEntity to configure the HTTP Response.
	We can add ResponseEntity in both the Controller and the Service Layer. 
	Since we are trying to return a Status Code as well as handle exceptions, we will use it in Service Layer.
	
	Before ResponseEntity was used and exceptions were handled getAllQuestions() looked like this: 
	----------------------------------------------------------------------------------------------
		Service Layer:
		--------------
			public List<Question> getAllQuestions() 
			{
				return qDAO.findAll();
			}
		
		Controller Layer 
		----------------
			@GetMapping("allQuestions")		
			public List<Question> getAllQuestions()
			{
				return qService.getAllQuestions();
			}
	
	After Adding ResponseEntity and handling exceptions, the functions look like this:
	----------------------------------------------------------------------------------
		Service Layer:
		--------------
			public ResponseEntity<List<Question>> getAllQuestions() 
			{
				
				try
				{
					// If the request sent by user is correct, we will return Status Code OK.
					return new ResponseEntity<>(qDAO.findAll(), HttpStatus.OK) ;
				}
				catch(Exception e)
				{
					// printStackTrace() can pin-point exactly which line is causing the error to appear.
					e.printStackTrace();
				}
				// If the request sent by user is incorrect, we will return Status Code Bad Request. 
				return new ResponseEntity<>(qDAO.findAll(), HttpStatus.BAD_REQUEST) ;
			}
		
		Controller Layer:
		-----------------
			@GetMapping("allQuestions")		
			public ResponseEntity<List<Question>> getAllQuestions()
			{
				return qService.getAllQuestions();
			}

	The Controller Layer's getAllQuestions() now should return an object of ResponseEntity<List<Question>> i.e., the Data and the Status Code.
	Hence, we changed it's type from "List<Question>" to "ResponseEntity<List<Question>>". Takes the input from the user and send it to the 
	Service Layer's getAllQuestions(), which sends Data and the Status Code back.
	
	In the service layer, first the request is checked if it's a valid one or not, returning 200 OK and 400 Bad Request respectively.
	Next we check if there's any error/exception which is handled by the try-catch block.

{
        "category": "JAVA",
        "difficultyLevel": "Easy",
        "questionTitle": "How many primitive data types are there in Java?",
        "option1": "6",
        "option2": "7",
        "option3": "8",
        "option4": "9",
        "rightAnswer": "8. They are: int, short, double, float, long, char, boolean, byte"
}