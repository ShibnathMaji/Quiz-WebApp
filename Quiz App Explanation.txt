Quiz App
---------
Goals:
	User accessing the appplication will get a set of 10 MCQ questions which they would need
	to answer. They will be scored based on their answers to the quiz.
	This is completely Backend Web Application. 
	Hence, to verify the APIs, we'll be using Postman.
	
Tech Stacks Used: 
	1. Spring Boot 
	2. Java 11
	3. PostgreSQL

Dependencies Used:
	1. Spring Web :	Used to create the Web Application
	2. PostgreSQL Driver : 	It helps access data in PostgreSQL DB.
	3. Spring Data JPA:	It allows us to connect to the Spring app and the DB.
	4. Lombok:	For reducing Boilerplate code.
	   
Procedure:
	This Quiz web application is a Restful WebService.
	The questions being asked to the user, is stored in the PostgreSQL DB.
	
	The application has three layers, each with their own functions:
		1. Controller Layer:
			- It is responsible for interacting with the users and accept their requests.
			- Sends the requests to be processed in the service layer.
			- Returns the output from the service layer to the User. 
		
		2. Service Layer:
			- All the business logic required by the application stays here.
			- Processing is done here.
			- Controller Layer passes on the requests from the user to this layer, for processing
		
		3. DAO Layer:
			- This layer is responsible for interacting with the DB (perform CRUD operations)
			- DAO layer is used to decouple the Service layer from the DB.
			
	To implement the three layers mentioned above, there are three packages:
		com.example.quizwebapp.controller
		com.example.quizwebapp.service
		com.example.quizwebapp.dao
	which contains all of the Controller, Service and DAO classes respectively.
	
	The annotations used:
	1. @RestController
		- It tells the Spring framework that this class will be a Controller in the Spring MVC.
		- Since we are building a RESTful Web Application capable of serving REST APIs (GET, POST, PUT etc),
		  all the controllers in this application will be annotated with @RestController.
		- This annotation also combines @controller and @ResponseBody annotatios, so we don't need to use them seperately.
	
	2. @Service
		- It tells the Spring framework that this class will belong in the Service layer.
		- Signifies that the class is holding business logic.
	
	3. @Autowired
		- This annotation allows for automatic dependency injection
		- It automatically scans the components present in the current package and the sub packages.
		- Components are usually marked with @Component, @Service, @Repository or @Controller annotations.
	
	4. @Entity
		- It is used to show that a class can be mapped to a table.
		- In JPA, @Entity is used to show a table that's stored in a DB.
	
	5. @Table
		- Used to mention which table will be mapped to the Entity/Model class.
		
	6. @Id
		- Denotes which variable will serve as the Primary Key of the Entity class.
		
	7. @Data
		- This is present in the Lombok dependency.
		- It is used to add Getter and Setter methods for all the fields mentioned in a class.
		
	8. @Repository
		- It tells the Spring framework that this class/interface will belong in the DAO layer.
		- It signifies this class contains code for Database used for storage, retrieval, 
		  update, delete and search operations.
	
	Now coming to the DB, for each table we use in the application, we create one class.
	This class is called an Entity or a Model and contains the data of the application. 
	The fields (variables) used in the Entity/Model class, represents the columns present in the table.
	
	SQL uses "snake_casing" while Java uses "camelCasing".  
	For a column in the table named "difficult_level", we can use the variable name "difficultyLevel" in our model class.
	This is becasue we are using JPA, whose object-relational mapping (ORM) framework makes sure this happens.
	
	Make sure the PostgreSQL Table name uses the following naming conventions: https://www.geeksforgeeks.org/postgresql-naming-conventions/
	For example, if the table name is "table_name", we can use @Table(name = "TableName")